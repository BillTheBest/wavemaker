
dojo.provide("wm.base.design.Drag");

dojo.declare("wm.ResourceMover", wm.DragDropper, {
	constructor: function() {
		this.info = {};
	},
	beginDrag: function(inEvent, inInfo) {
		this.info = inInfo || this.info;
		this.mousedown(inEvent);
	},
	initNodes: function() {
		this.inherited(arguments);
		// make a drop marker
		this.markNode = document.createElement("div");
		this.markNode.style.cssText = "position: absolute; z-index: 2; border: 2px solid green;";
		this.scrimNode.appendChild(this.markNode);
		// make snap markers
		this.hSnapNode = document.createElement("div");
		this.hSnapNode.style.cssText = "position: absolute; z-index: 2; border: 1px dotted red; display: none;";
		this.scrimNode.appendChild(this.hSnapNode);
		// make snap markers
		this.vSnapNode = document.createElement("div");
		this.vSnapNode.style.cssText = "position: absolute; z-index: 2; border: 1px dotted red; display: none;";
		this.scrimNode.appendChild(this.vSnapNode);
	},
	start: function(e) {
		this.target = null;
		kit._setMarginBox(this.markNode, 0, 0, 0, 0);
		this.root = window.studio ? studio.page.root : app._page.root;
		this.rootOffset = wm.calcOffset(this.root.domNode.parentNode, this.scrimNode);
		this.inherited(arguments);
		this.setTarget(null);
		this.designable = this.isDesignable();
	},
	drag: function(e) {
		this.inherited(arguments);
		// calc a target rect
		var r = { l: this.pxp - this.rootOffset.x, t: this.pyp - this.rootOffset.y, w:0, h: 0};
		// locate target
		this.findTarget(r);
		if (this.target && this.designable) {
			// calculate suggested drop rect
			var r = { l: this.pxp - this.targetOff.x, t: this.pyp - this.targetOff.y, w:0, h: 0, dx: this.dx, dy: this.dy};
			this.target.suggestDropRect(this.info.control, r);
			// position the drop marker
			kit._setMarginBox(this.markNode, r.l + this.targetOff.x, r.t + this.targetOff.y, r.w, r.h);
			// position the snap markers
			wm.showHideNode(this.hSnapNode, Boolean(r.hSnap));
			if (r.hSnap) {
				r.hSnap.l += this.targetOff.x;
				r.hSnap.t += this.targetOff.y;
				kit.marginBox(this.hSnapNode, r.hSnap);
			}
			wm.showHideNode(this.vSnapNode, Boolean(r.vSnap));
			if (r.vSnap) {
				r.vSnap.l += this.targetOff.x;
				r.vSnap.t += this.targetOff.y;
				kit.marginBox(this.vSnapNode, r.vSnap);
			}
			// cache drop position
			this.dropRect = r;
		} 
	},
	drop: function(e) {
		if (this.target && this.target.layout.removeEdges)
			this.target.layout.removeEdges(this.target);
		this.inherited(arguments);
	},
	setTarget: function(inTarget){
		if (this.target && this.target.layout.removeEdges)
			this.target.layout.removeEdges(this.target);
		this.target = inTarget;
		if (this.target) {
			this.setCursor("default");
			this.targetNode = this.target.containerNode || this.target.domNode;
			this.targetOff = wm.calcOffset(this.targetNode, this.scrimNode, true);
		} else {
			this.setCursor("no-drop");
			this.targetNode = null;
			this.targetOff = null;
		}
		if (this.target && this.target.layout.renderEdges)
			this.target.layout.renderEdges(this.target, this.info.control);
		this.updateAvatar();
	},
	updateAvatar: function() {
		this.showHideAvatar(Boolean(this.target));
		if (this.target) {
			var dn = this.designable ? this.target.name : this.root.owner.type;
			this.setAvatarContent("Drop <b>" + this.info.caption + "</b>" + " into <b>" + dn + "</b>");
		}
	},
	findTarget: function(inHit) {
		var t;
		if (this.targetInRoot(inHit)) {
			t = (this.designable ? this._findTarget(inHit, this.root) : this.root);
		}
		if (!t)
			kit._setMarginBox(this.markNode, 0, 0, 0, 0);
		if (t != this.target) {
			this.setTarget(t);
		}
	},
	_findTarget: function(inHit, inWidget, inMargin) {
		var h = inHit, dn = inWidget.domNode, w, b, o;
		var sl = dn.scrollLeft, st = dn.scrollTop;
		var ws = inWidget.widgets;
		var m = inMargin || 0;
		for (var i in ws) {
			w = ws[i];
			if (w != this.info.control && w.container && !w.getLock()) {
				b = kit._getMarginBox(w.domNode);
				if (w.domNode.parentNode != inWidget.domNode){
					// offset from target rect to hit frame
					o = wm.calcOffset(w.domNode.parentNode, inWidget.domNode);
					b.l += o.x; 
					b.t += o.y;
				} else {
					b.l -= sl; 
					b.t -= st;
				}
				// must be well inside
				b.r = b.l + b.w; 
				b.b = b.t + b.h;
				if (h.l-b.l>m && b.r-h.l>m && h.t-b.t>m && b.b-h.t>m) {
					h.l -= b.l; 
					h.t -= b.t;
					return this._findTarget(h, w, m+1);
				}
			}
		}
		// FIXME: sort out _noCreate
		var t = inWidget._noCreate ? inWidget.parent : inWidget;
		return this.canBeTarget(t) ? t : null;
	},
	canBeTarget: function(inWidget) {
		return inWidget.container && !inWidget.flags.notInspectable && !inWidget.getFreeze();
	},
	targetInRoot: function(inHit) {
		var h = inHit, b = kit._getMarginBox(this.root.domNode);
		return !(h.l < 0 || h.t < 0 || h.l > b.w || h.t > b.h);
	},
	isDesignable: function() {
		var c = this.info.control || (dojo.getObject(this.info.type)).prototype;
		return c instanceof wm.Control;
	}
});


dojo.declare("Main", wm.Page, {
    dndElements: null,
    //resourcePalette: null,
    start: function() {
	this.dndElements = [["Folder", "A folder for your resources", "foldericon.jpg"],
			    ["Image", "A graphics resource file", "picture.png"],
			    ["JS Library", "A javascript resource file", "jscript.jpg"],
			    ["CSS Library", "A CSS resource file", "css.jpg"],
			    ["Misc", "A misc resource (.swf, .txt, .etc)", "document.jpg"]];
	//console.group("HEY HO");console.dir(main.resourcePalette);console.groupEnd();
	//this.resourcePalette = main.resourcePalette;
	var resourcePalette = this.resourcePalette;

	this.dndElements.forEach(function(item) {
	    resourcePalette.addItem(item[0],item[1],item[2]);
	    });	
  },
  _end: 0
});

dojo.declare("wm.ResourcePalette", wm.Tree, {
	init: function() {
		this.items = [];
		this.inherited(arguments);
		this.connect(this.domNode, "onmousedown", this, "mousedown");
		this.dragger = new wm.ResourceMover();
		this.dragger.ondrop = dojo.hitch(this, "dragDrop");
		this.node = new wm.TreeNode(this.root, {content: "Resources",
							  name: "Resources",
							  closed: false});
	},
	mousedown: function(e) {
		var t = this.findEventNode(e);
		if (t) {
			if (t.klass)
				this.drag(e, t.klass, t.props);
			else if (t.parent == this.root && e.target != t.btnNode)
				t.setOpen(t.closed);
		}
	},
	drag: function(inEvent, inType, inProps) {
		if (!studio.page)
			return;
			this.dragger.beginDrag(inEvent, {
				caption: inType,
				type: inType,
				props: inProps
			});
	},
	dragDrop: function() {
		if (!this.dragger.target)
			return;
		/*
		var info = this.dragger.info;
		var props = dojo.clone(info.props || {});
		var ctor = dojo.getObject(info.type);
		dojo.mixin(props, {
			_designer: studio.page._designer,
			name: studio.page.getUniqueName(props.name || studio.makeName(info.type)),
			owner: studio.page,
			parent: this.dragger.target
		});
		if (ctor.prototype instanceof wm.Control) {
			props.height = ctor.prototype.height || props.height || "48px";
			props.width = ctor.prototype.width  || props.width || "96px";
		}
		var comp = new ctor(props);
		if (comp) {
			if (!(comp instanceof wm.ServerComponent)) {
				// create an undo task
				new wm.AddTask(comp);
			}
			if (comp instanceof wm.Control) {
				//comp.designMoveControl(this.dragger.target, this.dragger.dropRect);
				this.dragger.target.designMoveControl(comp, this.dragger.dropRect);
			}
			if (!wm.fire(comp, "afterPaletteDrop")) {
				// FIXME: should not refresh entire tree when dropping from palette.
				studio.refreshDesignTrees();
				studio.inspector.resetInspector();
				studio.select(comp);
			}
		}
		*/
	},
	addItem: function( inName, inDescription, inImage, inClass, inProps) {
			wm.fire(this.findItemByName(inName, this.node), "destroy");

			var n = new wm.TreeNode(this.node, {
			    name: inName,
			    content: inName,
			    image: inImage,
			    klass: inClass,
			    props: inProps
			});
	},


	findItemByName: function(inName, inParent) {
		inParent = inParent || this.root;
		for (var i=0, nodes=inParent.kids, n; (n=nodes[i]); i++) {
			if (inName == (n||0).name)
				return n;
		}
	},
	select: function() {
	},
	// bc
	setLayerIndex: function() {
	},
	clearSection: function(inName) {
	    /*
		var p = this.findItemByName(inName);
		if (p) {
			dojo.forEach(p.kids, function(n) {
				delete wm.ResourcePalette.items[n.klass];
			});
			p.removeChildren();
		}
	    */
	},
	removeSection: function(inName) {
	    /*
		wm.fire(this.findItemByName(inName), "destroy");
	    */
	}
});

wm.ResourcePalette.items = [];
